# software-engineering
This is my software engineering experiment`s homework.

# 垃圾短信过滤系统

## 软件工程导论
## 《软件测试报告》

# 一、	引言
### 1.	编写目的
#### 1.1 测试报告主要目的
软件测试的目的是为了保证软件产品的最终质量，在软件开发的过程中，对软件产品进行质量控制。一般来说软件测试应由独立的产品评测中心负责，严格按照软件测试流程，制定测试计划、测试方案、测试规范，实施测试，对测试记录进行分析，并根据回归测试情况撰写测试报告。测试是为了证明程序有错，而不能保证程序没有错误。
#### 1.2 测试内容
1.	移动终端的过滤选项是否正常。<br>
2.	移动终端的准确性是否可以接受。<br>
3.	移动终端的过滤措施是否完善。<br>
4.	后台数据库的管理。<br>
## 2.	项目背景
手机短信的安全问题已经得到了社会的关注，如何限制垃圾短信的传播，保持手机用户的人身财产安全是一个亟待解决的问题。当前的主要方法是各大移动运营商在服务器上建立短信监控过滤系统，对短信进行有效的监控和过滤。尽管如此，还是有大量的垃圾短信通过各种渠道发送给广大的手机用户。本文通过研究目前垃圾短信过滤途径的问题，提出了基于手机客户端的垃圾短信过滤方法，它是一种基于短信内容的过滤方法，有效的解决了手机用户接收垃圾短信的问题。

## 3.	参考资料
1.	软件需求参考《软件需求说明书》。<br>
2.	软件详细设计参考《软件设计说明书》。<br>
# 二、	运行环境部署
软件/硬件	名称	版本<br>
手机	小米6	<br>
CPU	高通骁龙	835<br>
内存	RAM	4G<br>
操作系统	Android	7.1.1<br>
网络支持	WCDMA GPRS	3.0<br>

# 三、	软件代码层面测试
## 1.	公共模块
````java
class Trainer_bayes:
    def __init__(self, training_data, training_target):
        self.training_data = training_data
        self.training_target = training_target
        self.clf = GaussianNB()
    def train_classifier(self):
        self.clf.fit(self.training_data, self.training_target)
        joblib.dump(self.clf, 'model/bayes_estimator.pkl')
        training_result = self.clf.predict(self.training_data)
        print (metrics.classification_report(self.training_target, training_result))

    def cross_validation(self):
        cv = ShuffleSplit(n_splits=5, test_size=0.2, random_state=20)
        scores = cross_val_score(self.clf, self.training_data, self.training_target, cv=cv, scoring='f1_macro')
        print (scores)
        print("Accuracy: %0.2f (+/- %0.2f)" % (scores.mean(), scores.std() * 2))
````
主要任务将短信数据进行贝叶斯训练，达到一定的程度作为函数模块进行垃圾短信的识别。


## 2.	专用模块
````java
class Predictor:
    def __init__(self, test_data, test_target):
        self.test_data = test_data
        self.test_target = test_target

    def sample_predict(self, clf):
        test_result = clf.predict(self.test_data)
        print (metrics.classification_report(self.test_target, test_result))
        print (metrics.confusion_matrix(self.test_target, test_result))

    def new_predict(self, clf):
        test_result = clf.predict(self.test_data)
        with open('result/predict_label.txt', 'wt') as f:
            for i in range(len(test_result)):
                f.writelines(test_result[i])
        self.test_target = test_result
        print ('write over')
````
	此模块是专门用来进行垃圾短息的预测功能，识别出垃圾短息。


## 3.	信息存储
````java
class DB_manager:
    client = MongoClient()
    db = client.test1
    training_data = db.training_datas

    def import_training_data(self, word_vector_file, train_label_file):
        self.training_data.delete_many({})
        self.training_data.create_index('training_num')
        word_vector = io.mmread(word_vector_file)
        vector = np.array(word_vector.todense())
        with open(train_label_file, 'r') as f:
            label = json.load(f)

        num = len(label)
        for i in range(num):
            dic = {}
            dic['training_num'] = i
            dic['vector'] = list(vector[i])
            dic['label'] = int(label[i])
            self.training_data.insert_one(dic)
````
	这个模块的功能是将识别出的垃圾短信回收到数据库中。
        
# 四、	软件编码实现
## 1.	编码风格
	清晰性	效率	开发时间<br>
	程序	输出	内存数	语句数	<br>
程序可得性最佳	1-2	2	3	3	4<br>
输出可读性最佳	1-2	1	5	5	2-3<br>
占内存最少	4	4	1	2	2-3<br>
语句数最少	5	3	2	1	2-3<br>
开发时间最短	3	5	4	4	1<br>
## 2.	名字
1.	名字-非形式的、简练的、容易记忆的。<br>
2.	一个变量的作用越大，名字所携带的信息越多。<br>
3.	全局变量-使用具有说明性的名字，并加以注释。<br>
4.	局部变量-用短名字。<br>
5.	保持一致性。<br>
6.	函数采用动作性动词，后面可以跟着名词。<br>
## 3.	表达式和语句
1.	用缩行显示程序的结构。<br>
2.	使用表达式的自然形式。<br>
3.	避免含有否定运算的条件表达式。<br>
4.	可以改变关系运算方向，变成肯定的。<br>
5.	用加括号方式排除二义性。<br>
6.	分解复杂的表达式。<br>
# 五、	软件测试计划与执行
## 1.	测试项目
项目名称	垃圾短息拦截系统	测试版本	1.0<br>
测试环境	硬件：<br>
内存：4G<br>
CPU：高通骁龙<br>
      软件：<br>
          操作系统：Android<br>

## 2.	测试内容
1.	功能测试：主要测试系统是否实现预计结果，此测试为软件的基本测试，主要参考对象为业主用户，开发人员，测试人员等。<br>
2.	性能测试：性能测试主反应系统反应时间，CPU使用率，占用内存大小，系统反应速度等硬性指标。主要参考对象为业主用户，开发经理，开发人员，测试人员等。<br>
3.	安全性测试：安全测试是在IT软件产品的生命周期中，特别是产品开发基本完成到发布阶段，对产品进行检验以验证产品符合安全需求定义和产品质量标准的过程 。<br>
4.	兼容性测试：指对所设计程序与硬件、软件之间的兼容性的测试<br>


## 3.	测试阶段
阶段	内容	开始日期	结束日期	负责人<br>
阶段一	模块测试	2017.12.23	2017.12.25	<br>
阶段二	功能测试	2017.12.26	2017.12,29	<br>
阶段三	性能测试	2017.12.25	2017.12.28	<br>
阶段四	安全性测试	2017.12.28	2017.12.30	<br>
阶段五	兼容性测试	2017.12.29	2017.12.31	<br>
阶段六	界面测试	2017.12.30	2018.01.02	<br>

## 4.	系统情况
序号	测试名称	测试内容	测试目的	测试人<br>
1	算法训练	导入测试数据进行训练	系统正常测试	<br>
2	算法测试	基于训练的算法进行测试	测试显示结果大部分正常	<br>

3	短信预测	将短信进行预测：判断出正常短信与垃圾短息	判断出垃圾短息与正常短信	<br>

4	测试准确率	计算软件功能的准确性	准确性还算理想	<br>

## 5.	测试准备和任务
### 5.1 测试前准备工作
1.	阅读和审查软件需求分析、设计文档。<br>
2.	审查源代码（符合编码规范与测试要求）。<br>
3.	设计测试用例（符合软件需求分析要求）。<br>
4.	搭建测试环境（包括硬件环境、软件环境、数据环境）。<br>
5.	编写测试计划。<br>
### 5.2 测试过程中任务
1.	执行测试。<br>
2.	报告测试结果。<br>
3.	评估测试效果。<br>
### 5.3 测试完成后任务
1.	编写测试报告。
## 6.	测试用例
### 6.1 功能测试
软件功能测试也叫黑盒测试或数据驱动测试，只需考虑需要测试的各个功能，不需要考虑整个软件的内部结构及代码。一般从软件产品的界面、架构出发，按照需求编写出来的测试用例，输入数据在预期结果和实际结果之间进行评测，进而提出更加使产品达到用户使用的要求。
#### 1.	测试用例：垃圾短信拦截
用例标识	1		项目名称	垃圾短息拦截系统<br>
测试人员			模块名称	登录功能<br>
测试类型	功能测试		设计日期	2017-12-23<br>
测试方法	黒盒测试		测试日期	2017-12-23<br>
用例描述	该用例主要是用来测试系统是否将受到的垃圾短信进行拦截<br>
前置条件	系统运行正常，处于正常可操作状态<br>
描述操作	1、打开APP，进入主页面。<br>
#### 2、系统在后台运行。

编号	角色	短信	正确预测	预期结果	实际结果	备注<br>
01	测试人员	但是没有首都的在CBD一家好吃	不是	不是	不是	<br>
02	测试人员	今天给大家介绍一款Bookbook电脑包	不是	不是	不是”	<br>
03	测试人员	亲爱的家长朋友你们好，我是张老师:新学期现在开始报名啦！本学期对老生家长的义务宣传有个回馈活动，老生带一个新生报名，赠送老生二百元兴趣	是	是	是”	<br>
04	测试人员	浙江宁波市马路突然爆裂	不是	不是	不是	<br>
05	测试人员	各位亲们好，新世纪奉节店迎接三八节，贝因美奶粉全场x.x折，欢迎惠额。活动时间x月x日至x月x日。	是	是	是	<br>

### 6.2 性能测试
测试系统在预定环境和负载下的响应速度。通信效率、设备效率、执行效率。<br>
序号	用例名称	基本要求	测试情况	测试通过<br>
				是	否<br>
1		拦截垃圾短信	一条一条的发送短信	可以正常拦截	☑	<br>
2		拦截垃圾短信	超过100条短信一起接收	可以正常拦截	☑	<br>
1.	核心模块测试用例<br>
极限名称	最大并发用户数<br>
前提条件	系统在该用户数目下能正常运行<br>
运行时间	一直运行<br>
输入/动作	输出/响应	是否能正常运行	故障发生的时刻	故障描述<br>
单个短信接收		能够正常拦截	<br>	
100条短信同时接受		能够正常拦截		<br>
500条短信同时接受		能够正常拦截		<br>
800条短信同时接受		不能正常拦截	接收片刻	拦截失败<br>

2.	执行效率<br>
并发用户数	平均响应时间（秒）<br>
	接收	拦截<br>
  1	0.1	0.01<br>
100	0.1	0.01<br>
500	0.1	0.01<br>
800	0.1	0.01<br>
### 6.3 可靠性测试
测试内容	基本要求	测试情况	测试通过<br>
			是	否<br>
掉电	手机掉电或强行关机后重启机器，不丢失数据。	实现要求	☑	<br>
合法短信	对于合法短信手机将会进行提示	实现要求	☑	<br>
垃圾短息	对于垃圾短信系统将会自动存放到垃圾短息文件夹且不会提醒用户	实现要求	☑	<br>
后台清理	将系统存后台删除后，重新打开依旧可以实现垃圾短信拦截	实现要求	☑	<br>
### 6.4 安全性测试
测试内容	基本要求	测试情况	测试通过<br>
			是	否<br>
用户权限	所有授权用户是否能在所授权限下进行工作，不容许超权限。	实现要求	☑	<br>
隐私保护	系统不会自动获取用户私人信息	实现要求	☑	<br>
### 6.5 易用性测试
测试内容	基本要求	测试情况	测试通过<br>
			是	否<br>
窗口切换	窗口切换、移动、改变大小时正常	实现要求。	☑	<br>
界面元素文字	各种界面元素的文字正确（如标题、提示等）	实现要求	☑	<br>
界面元素状态	各种界面元素的状态正确（如有效、无效、选中等状态）	实现要求	☑	<br>
触屏操作	各种界面元素支持触屏操作	实现要求	☑	<br>
阅读手册	对于常用的功能，用户能否不必阅读手册就能使用	没有实现要求		☑<br>
风险提示	执行有风险的操作时，有“确认”、“放弃”等提示	没实现要求		☑<br>
联机帮助	提供完善的联机帮助	没有实现要求		☑<br>
界面布局	各种界面元素的布局合理、美观	实现要求	☑	<br>
界面颜色	各种界面元素的颜色协调	实现要求	☑	<br>
界面形状	各种界面元素的形状美观	实现要求	☑	<br>
字体	字体美观	实现要求	☑	<br>
图标	图标直观	实现要求	☑	<br>
### 6.6 兼容性测试
测试内容	基本要求	测试情况	测试通过<br>
			是	否<br>
平台兼容性	安卓手机最新系统	正常使用	☑	<br>

# 六、	软件测试结论
## 1.	功能性测试
由于编写代码的过程中就是不断地进行代码调试，功能类似于对源代码进行白盒测试，所以在这里主要使用黑盒测试的方法对客户端进行系统集成测试。下面是各模块的测试结果。
### 1.	短信截获模块测试
系统可以接收到用户收到的短信，同时先停止手机正常接收，当判断完成在开启正常接收功能。经过真机测试显示，当发送消息为正常消息时，系统不会拦截该短信，反之手机将不会接收到该短信。
### 2.	黑白名单模块测试
系统可以获取联系人名单作为白名单用户，同时可以手动添加黑名单用户。同时，手机关机重启后，黑名单可以保持正常，当系统设置了自动拦截模式后，过滤系统将不过滤白名单用户的短信，同时系统也将强制过滤黑名单用户的短息。
### 3.	贝叶斯分类模块测试
系统可以对短信进行正确的分类。在之前的算法介绍中已经对贝叶斯分类模块的性能进行了系统的测试比较，因此此处只是对该模块的功能进行验证。
### 4.	系统设置模块测试
系统可以识别用户的设置，并根据用户的设置进行过滤。本次测试主要针对系统的几大拦截模式（普通拦截、智能拦截、只接受白名单、只接受黑名单、全部接受）进行单独的功能测试，测试结果表明：系统可以按照不同的拦截模式进行采用拦截方式，符合前面章节的设定。
### 5.	自学习模块
系统可以进行自行学习，同时学习的短信在经过分类后才能够正常存入语料库。本模块主要是在PC上进行测试，经测试表明，当系统进行学习之后，相应的短信被成功的分词、提取特征向量之后存入了语料库，语料库中该类别的短信数目也随之增加。
### 6.	规则自定义模块测试
系统可以根据用户对垃圾短信的不同定义来进行相应的过滤规则的调整。此处我们对中奖类诈骗，冒充银行诈骗、违法票据、房地产促销，二手车、零售业网购诈骗、贷款诈骗，色情这几单类别进行了分别测试。测试方法是当用户设置相应的类别时，再次接收到相关的垃圾短信将不会被过滤也就是说系统将会将相应的特征向量送入重新组合的语料库中。
# 七、	测试分析结论
本文实现的短信自动分类和动态反馈的系统，达到了较好的效果。但是由于时间以及实验条件的限制及工作还需进一步的完善。<br>
1.	目前国内缺少一个标准的短信分类样本，库尔贝叶斯分类是建立在大量样本统计的基础上，本文自建的样本空间不够大，自身对短信的判断标准，并不一定适合所有用户，因此接待国内的相关机构能够建立一个公开，真实透明的短信分类样本库，积极促进对短信分类的研究。<br>
2.	还有其他分类算法对一般的文本分类，表现出较好的效果。而对于短信的分类效果还需要进一步的测试验证。<br>
3.	由于时间和硬件设备条件有限，本文提出的系统进行在Android上进行了测试。但是由于众多基于symbian和Linux的手机无法通过进行测试，因此在条件允许的情况下将会对其他系统的手机软件系统进行移植测试工作。<br>
